var documenterSearchIndex = {"docs":
[{"location":"internals/matrix_elements/","page":"Matrix elements","title":"Matrix elements","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/matrix_elements/#Matrix-elements","page":"Matrix elements","title":"Matrix elements","text":"","category":"section"},{"location":"internals/matrix_elements/","page":"Matrix elements","title":"Matrix elements","text":"Pages = [\"matrix_elements.md\"]","category":"page"},{"location":"internals/matrix_elements/#Types","page":"Matrix elements","title":"Types","text":"","category":"section"},{"location":"internals/matrix_elements/","page":"Matrix elements","title":"Matrix elements","text":"Modules = [BialkaliSpectrum]\nPages = [\"matrix_elements.jl\"]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"internals/matrix_elements/#Methods","page":"Matrix elements","title":"Methods","text":"","category":"section"},{"location":"internals/matrix_elements/","page":"Matrix elements","title":"Matrix elements","text":"Modules = [BialkaliSpectrum]\nPages = [\"matrix_elements.jl\"]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"internals/matrix_elements/#BialkaliSpectrum.T⁽¹⁾Iₖ-Tuple{Int64, Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.T⁽¹⁾Iₖ","text":"T⁽¹⁾Iₖ(p, k, bra, ket)\n\nCompute the matrix elements of the pth component of the spherical tensor operator T¹(Iₖ), which acts on the kth nucleus.\n\nNote: in this function, Kronecker deltas are only enforced between the quantum numbers of the kth nucleus. The other quantum numbers are not required to match, because this tensor could be dotted with another operator, e.g., N ⋅ Iₖ, which allows mₙ to change.\n\nAny Kronecker deltas on the remaining quantum numbers must be enforced where the dot product is eventually taken.\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.T⁽¹⁾N-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.T⁽¹⁾N","text":"T⁽¹⁾N(p, bra, ket)\n\nCompute the matrix elements of the pth component of the spherical tensor operator T¹(N).\n\nNote: in this function, Kronecker deltas are only enforced between the rotational quantum numbers. The nuclear quantum numbers are not required to match, because this tensor could be dotted with another operator, e.g., N ⋅ Iₖ, which allows mᵢ to change.\n\nAny Kronecker deltas on the nuclear quantum numbers must be enforced where the dot product is eventually taken.\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.WignerJ1J-Tuple{Any, Any}","page":"Matrix elements","title":"BialkaliSpectrum.WignerJ1J","text":"WignerJ1J(j, m)\n\nReturns the same as WignerSymbols.wigner3j(j, 1, j, -m, 0, m), but computes it directly from the explicit formula.\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.WignerJ2J-Tuple{Any, Any}","page":"Matrix elements","title":"BialkaliSpectrum.WignerJ2J","text":"WignerJ2J(j, m)\n\nReturns the same as WignerSymbols.wigner3j(j, 2, j, -m, 0, m), but computes it directly from the explicit formula.\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.dipole_matrix_element-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.dipole_matrix_element","text":"dipole_matrix_element(p::Int, bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.nuclear_quadrupole-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.nuclear_quadrupole","text":"nuclear_quadrupole(k::Int, bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.nuclear_spin_rotation-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.nuclear_spin_rotation","text":"nuclear_spin_rotation(k::Int, bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.nuclear_spin_spin-Tuple{State, State}","page":"Matrix elements","title":"BialkaliSpectrum.nuclear_spin_spin","text":"nuclear_spin_spin(bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.rotation_matrix_element-Tuple{State, State}","page":"Matrix elements","title":"BialkaliSpectrum.rotation_matrix_element","text":"rotation_matrix_element(bra::State, ket::State)::Float64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.scalar_polarizability-Tuple{State, State}","page":"Matrix elements","title":"BialkaliSpectrum.scalar_polarizability","text":"scalar_polarizability(bra::State, ket::State)\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.tensor_polarizability-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.tensor_polarizability","text":"tensor_polarizability(p::Int, bra::State, ket::State)\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.zeeman_nuclear-Tuple{Int64, Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.zeeman_nuclear","text":"zeeman_nuclear(k::Int, p::Int, bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.zeeman_rotation-Tuple{Int64, State, State}","page":"Matrix elements","title":"BialkaliSpectrum.zeeman_rotation","text":"zeeman_rotation(p::Int, bra::State, ket::State)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/matrix_elements/#BialkaliSpectrum.δ-Tuple{Any, Any}","page":"Matrix elements","title":"BialkaliSpectrum.δ","text":"δ(i, j)\nδ(i::State, j::State)\n\nReturns the Kronecker δ between i and j.\n\nUses ==(i,j) if possible. If i and j are both State, then this function computes the product of the Kronecker δs over all quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"man/basics/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Pages = [\"basics.md\"]","category":"page"},{"location":"man/basics/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"This package is not yet registered with the Julia package manager.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"From the REPL, do","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"julia> import Pkg\njulia> Pkg.add(url=\"https://github.com/kylematsuda/BialkaliSpectrum.jl\")","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Now bring the package contents into scope:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"using BialkaliSpectrum","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"You can optionally also pull in molecule-specific definitions, which are kept in different submodules (BialkaliSpectrum.K40Rb87, BialkaliSpectrum.Toy, etc.):","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"using BialkaliSpectrum.K40Rb87 # optional, brings all KRb-specific stuff into scope","category":"page"},{"location":"man/basics/#First-calculation","page":"Getting started","title":"First calculation","text":"","category":"section"},{"location":"man/basics/#Setting-up","page":"Getting started","title":"Setting up","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Before doing the calculation, we need to do a little bit of setup:  construct the Hamiltonian and choose the external fields to use in the calculation:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"parts = make_krb_hamiltonian_parts(5);\nfields = ExternalFields(545.9, 0.0, []) # B = 545.9 G, E = 0, no optical fields","category":"page"},{"location":"man/basics/#Finding-the-energy-levels","page":"Getting started","title":"Finding the energy levels","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Next, we call get_spectrum, which diagonalizes the Hamiltonian (constructed from parts) at fields.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"spectrum = get_spectrum(parts, fields)","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"The output is a DataFrame. We can inspect its columns:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"names(spectrum)","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Descriptions of these fields can be found in the documentation for get_spectrum.","category":"page"},{"location":"man/basics/#Working-with-the-output-DataFrame","page":"Getting started","title":"Working with the output DataFrame","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"DataFrames.jl provides a nice API for manipulating the data that comes out of get_spectrum.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"BialkaliSpectrum.jl provides a few convenience methods for working with DataFrames. Documentation of these methods can be found here: DataFrame helpers. Let's try a few of them:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"filter_rotational(spectrum, 0, 0) # get only the N = 0, m_N = 0 states\nfilter_rotational(spectrum, [1, 2, 3]) # get everything in N = 1, 2, 3\nfilter_hyperfine(spectrum, -4, [1/2, 3/2]) # get m_K = -4, m_Rb = 1/2 or 3/2 states\nfilter_basis_state(spectrum, KRbState(2, 2, -3, -1/2)) # get the states whose nearest basis state is |2, 2, -3, 1/2>","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"All of these methods copy the results into a new DataFrame to avoid mutating the original. Typically, you'll want to calculate the spectrum first with  all of the levels you need (including for the dipole moments, etc. to converge), then use these methods to filter the states you actually care about into a new DataFrame.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"tip: Use DataFrames.jl\nFor more general transformations on DataFrames, see the docs at DataFrames.jl. Here are a few methods from DataFrames.jl that I've found especially useful:filter:    keep only the rows that match some predicate.\nselect:    keep only some of the columns of the DataFrame.\ntransform:    apply a function to the values in a column\nsort:    sort the rows according to the value of some column\ngroupby:    group the rows according to the value of some column.   This is especially useful when working with a big DataFrame that's the   aggregate of several spectra at different fields, and you want to split it   back up into the individual spectrum at each field.I've only listed the non-mutating versions, but all of these (except groupby) have  a mutating version (e.g., filter!, select!, etc.) that may be more efficient when working with large DataFrames, since you can avoid copying the entire DataFrame.","category":"page"},{"location":"man/basics/#Plotting-the-results","page":"Getting started","title":"Plotting the results","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Let's start off by using our calculated spectrum to plot the rotational transitions out of some state. We'll use the state we normally populate in KRb, 00-412rangle.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"If you're doing this in the REPL, as opposed to an Jupyter (IJulia) notebook, you'll need to add ElectronDisplay.jl,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"using ElectronDisplay","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Then, run the following line,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"using BialkaliSpectrum, BialkaliSpectrum.K40Rb87\nimport CairoMakie\n\nparts = make_krb_hamiltonian_parts(5);\nfields = ExternalFields(545.9, 0.0, []);\nspectrum = get_spectrum(parts, fields);","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_transition_strengths(spectrum, parts, KRbState(0, 0, -4, 1/2));\nCairoMakie.save(\"transition_strengths.svg\", ans); nothing # hide","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"This may be very slow on the first iteration, since Julia will need to compile CairoMakie if this is your first plot in the session. After a while, a new window should appear with an image that looks like this:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"These are the transitions coming out of KRbState(0, 0, -4, 1/2) as a function of the transition frequency. The height of the lines is the strength of their transition dipole,  normalized to d_textperm  sqrt3. Transitions with all three polarizations, pi, sigma^+ and sigma^-, are shown.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"By default, plot_transition_strengths only plots transitions with a  relative strength (keyword arg cutoff) greater than 1e-3. To plot all of the transitions with N = N pm 1, pass cutoff=nothing,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_transition_strengths(spectrum, parts, KRbState(0, 0, -4, 1/2); cutoff=nothing);\nCairoMakie.save(\"transition_strengths_nocutoff.svg\", ans); nothing # hide","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"which gives a plot like this:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Check out the docs for plot_transition_strengths for a full list of the allowed keyword arguments.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"What if we want to plot the transitions out of N = 1 instead?","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_transition_strengths(spectrum, parts, KRbState(1, 0, -4, 1/2));\nCairoMakie.save(\"transitions_N=1.svg\", ans); nothing # hide","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"This produces a weird-looking plot:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_transition_strengths plots transitions to both higher and lower states by default, so we are seeing transition to both the N = 0 and N = 2 manifolds. To make things clearer, we can supply the frequency_range parameter, which we have omitted so far. For example, if we want to plot the N = 2 transitions,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_transition_strengths(spectrum, parts, KRbState(1, 0, -4, 1/2), [4000, 5000]);\nCairoMakie.save(\"transitions_N=1_to0.svg\", ans); nothing # hide","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"This produces the following image:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"tip: hamiltonian_parts\nNote that plot_transition_strengths takes parts as a parameter  (written as hamiltonian_parts in the function signature). This is a common requirement for many of the analysis functions – in this case, the method needs the dipole matrix elements contained within parts  to calculate the transition strengths.There is another signature of plot_transition_strengths that doesn't take hamiltonian_parts as an argument. This variant assumes that you are passing in a DataFrame with the requisite fields already defined (coming from e.g., the output of transitions).","category":"page"},{"location":"man/basics/#Scanning-the-external-fields","page":"Getting started","title":"Scanning the external fields","text":"","category":"section"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"So far, we have shown a few examples of what we can do with the spectrum calculated for some particular value of the external fields. But we often want to calculate some property of the molecules as the external fields are changed.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"To do this, we will use a vector of ExternalFields instead of a single one,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"fields = generate_fields_scan(545.9, 0.0:1000.0:10000.0, [[]]);","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"This produces a Vector{ExternalFields} with a constant magnetic field of 545.9 G, a constant optical intensity of zero, and electric field strength increasing from 0 V/cm to 10 kV/cm in steps of 1 kV/cm. (This is a very coarse scan for the sake of this tutorial.)","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Next, we call get_spectra to calculate the spectrum at each field configuration,","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"spectra = get_spectra(parts, fields, df -> filter_rotational(df, [0, 1]))","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Notice that we passed a third parameter to get_spectra, an anonymous function df -> filter_rotational(df, [0, 1]). The third argument of get_spectra is a closure that's evaluated on the spectrum obtained at each field configuration before it's appended to the output DataFrame. In this case, we just applied a filter that removes all of the rows from the output except those corresponding to states with N leq 1.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"tip: Removing unneeded states\nFor field scans containing hundreds of points and many rotational levels, the amount of rows stored in the DataFrame can quickly become very large. In these cases, it can sometimes speed up the calculation a bit to throw away the unneeded states as soon as possible, as is done in this example.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"As an example, let's plot the energies as a function of the electric field:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"plot_states_adiabatic(spectra; groupby=:E);\nCairoMakie.save(\"energies.svg\", ans); nothing # hide","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"The following plot should pop up on your screen:","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"The \"fuzziness\" of the lines is because there are 36 hyperfine states per rotational state, which all have the same Stark shift.","category":"page"},{"location":"man/basics/","page":"Getting started","title":"Getting started","text":"Hopefully this is enough to get started! See the Public API docs for more details. We'll add a more complete example calculation at some point here: Example: dipole moments vs E.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"api/analyzing_spectrum/#Analyzing-the-results","page":"Analyzing the results","title":"Analyzing the results","text":"","category":"section"},{"location":"api/analyzing_spectrum/#Contents","page":"Analyzing the results","title":"Contents","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Pages = [\"analyzing_spectrum.md\"]","category":"page"},{"location":"api/analyzing_spectrum/#Index","page":"Analyzing the results","title":"Index","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Pages = [\"analyzing_spectrum.md\"]","category":"page"},{"location":"api/analyzing_spectrum/#Spectrum","page":"Analyzing the results","title":"Spectrum","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"These are the main functions for calculating the molecular spectrum.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"In most cases, you should just call get_spectra to calculate the spectrum at each point in a field_scan::Vector{ExternalFields}.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"A common pattern is to put the resulting spectra into transform_spectra to calculate quantities of interest at each point in the field_scan. transform_spectra groups spectra (the default is by :fields), then applies a transformation f to each subgroup. See the source for transitions for an example of this.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"get_spectrum can be called to calculate the spectrum at a single value of external_fields.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"TODO: get rid of get_spectrum?? When is it ever helpful? Then the utility functions might need to be extended to work on grouped dataframes as well?","category":"page"},{"location":"api/analyzing_spectrum/#Methods","page":"Analyzing the results","title":"Methods","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"get_spectrum\nfind_closest_eigenstate\nget_energy\nget_energy_difference\nget_spectra\ntransform_spectra","category":"page"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.get_spectrum","page":"Analyzing the results","title":"BialkaliSpectrum.get_spectrum","text":"get_spectrum(\n    hamiltonian_parts::HamiltonianParts,\n    external_fields::ExternalFields,\n)\n\nCompute the energies and eigenstates under the external fields.\n\nTo avoid reconstructing the Hamiltonian each time, hamiltonian_parts can be reused over calls to get_spectrum. The output is a DataFrame, with the following fields:\n\nField name Description\nfields value of external_fields\nB magnitude of external_fields.B\nE magnitude of external_fields.E\nindex index of the eigenenergy (from lowest to highest energy)\nenergy energy of the state (MHz)\neigenstate vector of state amplitudes\nbasis_index the index of nearest basis state (in wavefunction overlap) from hamiltonian_parts.basis\nN rotational number N of the nearest basis state\nm_n rotational projection m_n of the nearest basis state\nI_1 nuclear angular momentum I_1 of the nearest basis state\nm_i1 nuclear projection m_i1 of the nearest basis state\nI_2 nuclear angular momentum I_2 of the nearest basis state\nm_i2 nuclear projection m_i2 of the nearest basis state\n\nSee also get_spectra, make_hamiltonian_parts, make_krb_hamiltonian_parts, ExternalFields.\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.find_closest_eigenstate","page":"Analyzing the results","title":"BialkaliSpectrum.find_closest_eigenstate","text":"find_closest_eigenstate(spectrum, basis_state::State; tol=0.5)\n\nFind the row in spectrum whose :eigenstate has the highest overlap with basis_state.\n\nExample!!!\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.get_energy","page":"Analyzing the results","title":"BialkaliSpectrum.get_energy","text":"get_energy(spectrum, basis_state::State; tol = 0.5)\n\nFind the row in spectrum whose :eigenstate has the highest overlap with basis_state.\n\nExample!!!\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.get_energy_difference","page":"Analyzing the results","title":"BialkaliSpectrum.get_energy_difference","text":"get_energy_difference(spectrum, basis_g::State, basis_e::State; tol = 0.5)\n\nFind the row in spectrum whose :eigenstate has the highest overlap with basis_state.\n\nExample!!!\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.get_spectra","page":"Analyzing the results","title":"BialkaliSpectrum.get_spectra","text":"get_spectra(hamiltonian_parts, fields_scan, df_transform)\n\nCompute the energies and eigenstates at each point in fields_scan, applying df_transform to each intermediate spectrum.\n\nThe fields_scan can be conveniently generated with generate_fields_scan. The closure df_transform, which must have the signature DataFrame -> DataFrame, can be used to filter away unneeded rows (typically large N states), or to do further analysis.\n\nInternally, this method calls get_spectrum for each point in fields_scan, calls df_transform on each point (if provided), and vertically concatenates the results. The output is a DataFrame, see get_spectrum for details on the dataframe columns.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts, generate_fields_scan, get_spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.transform_spectra","page":"Analyzing the results","title":"BialkaliSpectrum.transform_spectra","text":"transform_spectra(spectra, f; groupby=:fields)\n\nA generic function for transforming the output of get_spectra.\n\nReturns the result of grouping spectra by groupby and applying f to each group, then combining the results into a new DataFrame. The signature of f must be DataFrame -> DataFrame.\n\nExample??\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#DataFrame-helpers","page":"Analyzing the results","title":"DataFrame helpers","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Utilities for working with the output of get_spectrum and get_spectra, both of which return a DataFrame.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"These are mainly simple filters or transforms, defined for convenience. Anything more complicated should use the methods in the DataFrames.jl library.","category":"page"},{"location":"api/analyzing_spectrum/#Methods-2","page":"Analyzing the results","title":"Methods","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Modules = [BialkaliSpectrum]\nPages = [\"dataframe.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.expand_fields!-Tuple{Any, Vector{Symbol}, Function}","page":"Analyzing the results","title":"BialkaliSpectrum.expand_fields!","text":"expand_fields!(df; magnitude_only=true)\nexpand_fields!(df, col_names::Vector{Symbol}, expander::Function)\n\nExpands the :fields column of df to new columns with the individual field parameters.\n\nIn the first variant, the optical fields are ignored.  If magnitude_only=true (default), then the :fields column is expanded to new columns :B and :E contaning fields.B.magnitude and fields.E.magnitude, respectively. This is convenient for plotting, so the values of E can be accessed as df.E (and similarly for df.B). If magnitude_only=false, then new columns for the field angles :θ_B, :ϕ_B, :θ_E, and :ϕ_E are added, in addition to the field magnitudes.\n\nThe second variant allows full control of the behavior. col_names is the list of the columns to add to df. expander must be a function fields -> Vector, which defines how a value in the :fields column is  transformed to the quantities named in col_names. This variant should be used for extracting the optical field parameters.\n\nAdd examples!\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_basis_state!-Tuple{Any, State}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_basis_state!","text":"filter_basis_state!(df, basis_state::State)\n\nRetains the rows of df whose :eigenstate is most overlapping with basis_state. This mutates df.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_basis_state-Tuple{Any, State}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_basis_state","text":"filter_basis_state(df, basis_state::State)\n\nReturns a new DataFrame containing the rows of df whose :eigenstate is most overlapping with basis_state.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_hyperfine!-Tuple{Any, Any, Any}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_hyperfine!","text":"filter_hyperfine!(df, m_i1, m_i2)\n\nRetains the rows of df where (row.m_i1 in m_i1) && (row.m_i2 in m_i2), removing the rest. This mutates df.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_hyperfine-Tuple{Any, Any, Any}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_hyperfine","text":"filter_hyperfine(df, m_i1, m_i2)\n\nReturns a new DataFrame containing the rows of df where (row.m_i1 in m_i1) && (row.m_i2 in m_i2).\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_rotational!-Tuple{Any, Any}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_rotational!","text":"filter_rotational!(df, N)    \nfilter_rotational!(df, N, m_n)\n\nRetains the rows of df where (row.N in N) && (row.m_n in m_n), removing the rest. This mutates df.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.filter_rotational-Tuple{Any, Any}","page":"Analyzing the results","title":"BialkaliSpectrum.filter_rotational","text":"filter_rotational(df, N)    \nfilter_rotational(df, N, m_n)\n\nReturns a new DataFrame containing the rows of df where (row.N in N) && (row.m_n in m_n).\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.wide_format-Tuple{Any, Any, Function}","page":"Analyzing the results","title":"BialkaliSpectrum.wide_format","text":"wide_format(spectra, valuecol, renamecols::Function; groupby=:fields)\n\nrenamecols is a function row -> String, where row is a row of a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#Extracting-physical-quantities","page":"Analyzing the results","title":"Extracting physical quantities","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Functions for analyzing the output of get_spectrum or get_spectra.","category":"page"},{"location":"api/analyzing_spectrum/#Methods-3","page":"Analyzing the results","title":"Methods","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Modules = [BialkaliSpectrum]\nPages = [\"analysis.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.adiabatic-Tuple{Any}","page":"Analyzing the results","title":"BialkaliSpectrum.adiabatic","text":"adiabatic(\n    spectra;\n    groupby=:fields,\n    radius::Union{Int,Nothing}=nothing\n)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.closest_basis_state-Tuple{HamiltonianParts, Any}","page":"Analyzing the results","title":"BialkaliSpectrum.closest_basis_state","text":"closest_basis_state(parts::HamiltonianParts, state)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.induced_dipole_moments-Tuple{Any, HamiltonianParts}","page":"Analyzing the results","title":"BialkaliSpectrum.induced_dipole_moments","text":"induced_dipole_moments(\n    spectra,\n    hamiltonian_parts::HamiltonianParts;\n    groupby=:fields\n)\n\nReturns a new DataFrame containing spectra with an additional column :d_ind, the induced dipole moment parallel to the applied electric field.\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.transitions","page":"Analyzing the results","title":"BialkaliSpectrum.transitions","text":"transitions(\n    spectra,\n    hamiltonian_parts::HamiltonianParts,\n    ground_basis_state::State,\n    frequency_range::Union{Vector,Nothing} = nothing;\n    groupby=:fields,\n    tol=0.5,\n    restrict_N=true,\n    keep_negatives=true,\n    cutoff::Union{Float64,Nothing}=1e-3\n)\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#Plotting","page":"Analyzing the results","title":"Plotting","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Methods for plotting data from get_spectrum and get_spectra using CairoMakie.","category":"page"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"In a REPL session, entering using ElectronDisplay will plot the figures in a pop-up window.","category":"page"},{"location":"api/analyzing_spectrum/#Methods-4","page":"Analyzing the results","title":"Methods","text":"","category":"section"},{"location":"api/analyzing_spectrum/","page":"Analyzing the results","title":"Analyzing the results","text":"Modules = [BialkaliSpectrum]\nPages = [\"plotting.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_induced_dipole-Tuple{Any, HamiltonianParts}","page":"Analyzing the results","title":"BialkaliSpectrum.plot_induced_dipole","text":"plot_induced_dipole(\n    spectra,\n    hamiltonian_parts::HamiltonianParts;\n    groupby=:E,\n    use_adiabatic=true\n)\n\nplot_induced_dipole(spectra; groupby=:E, use_adiabatic=true)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_states_adiabatic-Tuple{Any}","page":"Analyzing the results","title":"BialkaliSpectrum.plot_states_adiabatic","text":"plot_states_adiabatic(\n    spectra;\n    groupby=:E,\n    radius::Union{Int,Nothing}=nothing\n)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_states_adiabatic_weighted-Tuple{Any, Vector{State}}","page":"Analyzing the results","title":"BialkaliSpectrum.plot_states_adiabatic_weighted","text":"plot_states_adiabatic_weighted(\n    spectra,\n    states::Vector{State};\n    groupby=:E,\n    radius::Union{Int,Nothing}=nothing\n)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_transition_dipole-Tuple{Any, HamiltonianParts, State, Int64}","page":"Analyzing the results","title":"BialkaliSpectrum.plot_transition_dipole","text":"plot_transition_dipole(\n    spectra,\n    hamiltonian_parts::HamiltonianParts,\n    initial_state::State,\n    p::Int;\n    groupby=:E,\n    use_adiabatic=true,\n)\n\nplot_transition_dipole(\n    spectra,\n    initial_state::State,\n    p::Int;\n    groupby=:E,\n    use_adiabatic=true\n)\n\n\n\n\n\n","category":"method"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_transition_strengths","page":"Analyzing the results","title":"BialkaliSpectrum.plot_transition_strengths","text":"plot_transition_strengths(\n    spectrum,\n    hamiltonian_parts::HamiltonianParts,\n    ground_basis_state::State,\n    frequency_range::Union{Vector,Nothing} = nothing;\n    groupby=:E,\n    tol=0.5,\n    restrict_N=true,\n    keep_negatives=true,\n    cutoff::Union{Float64,Nothing}=1e-3,\n    normalization=1/sqrt(3)\n)\n\nplot_transition_strengths(\n    spectra;\n    groupby=:E,\n)\n\n\n\n\n\n","category":"function"},{"location":"api/analyzing_spectrum/#BialkaliSpectrum.plot_transitions_adiabatic","page":"Analyzing the results","title":"BialkaliSpectrum.plot_transitions_adiabatic","text":"plot_transitions_adiabatic(\n    spectra,\n    hamiltonian_parts::HamiltonianParts,\n    ground_basis_state::State,\n    frequency_range::Union{Vector,Nothing} = nothing;\n    groupby=:E,\n    tol=0.5,\n    restrict_N=true,\n    radius::Union{Int,Nothing}=nothing \n)\n\n\n\n\n\n","category":"function"},{"location":"internals/hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/hamiltonian/#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"internals/hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Pages = [\"hamiltonian.md\"]","category":"page"},{"location":"internals/hamiltonian/#Types","page":"Hamiltonian","title":"Types","text":"","category":"section"},{"location":"internals/hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Modules = [BialkaliSpectrum]\nPages = [\"hamiltonian.jl\"]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"internals/hamiltonian/#Methods","page":"Hamiltonian","title":"Methods","text":"","category":"section"},{"location":"internals/hamiltonian/","page":"Hamiltonian","title":"Hamiltonian","text":"Modules = [BialkaliSpectrum]\nPages = [\"hamiltonian.jl\"]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"internals/hamiltonian/#BialkaliSpectrum.h_diagonal-Tuple{Vector{State}, Function}","page":"Hamiltonian","title":"BialkaliSpectrum.h_diagonal","text":"h_diagonal(basis, matrix_element)\n\nCreate a diagonal matrix where the (i, i)th element is matrix_element(basis[i], basis[i]).\n\n\n\n\n\n","category":"method"},{"location":"internals/hamiltonian/#BialkaliSpectrum.h_rank_0-Tuple{Vector{State}, Function}","page":"Hamiltonian","title":"BialkaliSpectrum.h_rank_0","text":"h_rank_0(basis, matrix_element)\n\nCreate a matrix where the (i, j)th element is matrix_element(basis[j], basis[i]).\n\nNote that matrix_element must have the signature (State, State) -> ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"internals/hamiltonian/#BialkaliSpectrum.h_rank_1-Tuple{Vector{State}, Function}","page":"Hamiltonian","title":"BialkaliSpectrum.h_rank_1","text":"h_rank_1(basis, matrix_element)\n\nCreate a vector of 3 matrices to contract against a rank 1 spherical tensor.\n\nNote that matrix_element must have the signature (Int, State, State) -> ComplexF64. The first argument is the tensor component p in -1:1.\n\n\n\n\n\n","category":"method"},{"location":"internals/hamiltonian/#BialkaliSpectrum.h_rank_2-Tuple{Vector{State}, Function}","page":"Hamiltonian","title":"BialkaliSpectrum.h_rank_2","text":"h_rank_2(basis, matrix_element)\n\nCreate a vector of 5 matrices to contract against a rank 2 spherical tensor.\n\nNote that matrix_element must have the signature (Int, State, State) -> ComplexF64. The first argument is the tensor component p in -2:2.\n\n\n\n\n\n","category":"method"},{"location":"internals/hamiltonian/#BialkaliSpectrum.h_tensor_component-Tuple{Vector{State}, Function, Int64}","page":"Hamiltonian","title":"BialkaliSpectrum.h_tensor_component","text":"h_tensor_component(basis, matrix_element, p)\n\nCreate a matrix where the (i, j)th element is matrix_element(p, basis[j], basis[i]).\n\nNote that matrix_element must have the signature (Int, State, State) -> ComplexF64. The first argument is the tensor component p.\n\n\n\n\n\n","category":"method"},{"location":"man/worked_example/#Example:-dipole-moments-vs-E","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Pages = [\"worked_example.md\"]","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"This is a more complete worked example using BialkaliSpectrum.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Let's compute various dipole moments as a function of electric field!","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"For simplicity, we'll do the calculation without including hyperfine structure. BialkaliSpectrum has a module BialkaliSpectrum.Toy that defines molecular parameters for an idealized molecule without hyperfine structure.","category":"page"},{"location":"man/worked_example/#Setup","page":"Example: dipole moments vs E","title":"Setup","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"using BialkaliSpectrum, BialkaliSpectrum.Toy\nimport DataFrames, CairoMakie","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"We'll start by setting up a scan of the electric field:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"parts = make_toy_hamiltonian_parts(8);\nfields = generate_fields_scan(0.0, 0.0:0.2:4.0, [[]]);\nspectra = get_spectra(parts, fields, df -> filter_rotational(df, [0, 1, 2]))","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"This gives us the eigenstates and energies as a function of field.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"For the toy molecule, the molecular parameters are such that the characteristic field is E_c = B  d = 1 text Vcm. This is a bit of a weird situation, so let's try to make this somewhat  more clear by adding a new column :ϵ to the DataFrame, representing the unitless E-field parameter epsilon = EE_c:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"DataFrames.transform!(spectra, :E => DataFrames.ByRow(identity) => :ϵ);","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"We'll also want to use adiabatic here. This method adds a new column, :adiabatic_index. To obtain the values of these columns, the function first groups the DataFrame by :fields and  indexes the state in the first group in order of increasing energy; the value of :adiabatic_index is assigned to these index. The function next steps through the remaining groups, at each point giving each  eigenstate's :adiabatic_index to match the value of the eigenstate in the previous group with which it has the best overlap.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"In other words, adiabatic connects states for us across different fields based on the criterion of wavefunction adiabaticity as the field is changed. This lets us track states through avoided crossings, and distinguishes between real crossings and avoided ones.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"spectra = adiabatic(spectra);","category":"page"},{"location":"man/worked_example/#Plotting-the-induced-dipoles","page":"Example: dipole moments vs E","title":"Plotting the induced dipoles","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Having done this, let's now use induced_dipole_moments to compute the dipole moments, which are added in a column called :d_ind:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"dips = induced_dipole_moments(spectra, parts);\ndips.d_ind","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"We can now easily plot the dipole moments with plot_induced_dipole:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"plot_induced_dipole(dips; groupby=:ϵ);\nCairoMakie.save(\"induced_dipoles.svg\", ans); nothing # hide","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"(Image: )","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"note: Keyword arguments to the plotting function\nA bit of explanation:The groupby keyword argument sets the x-axis of the plot, and defaults to :E. In this case, we override the default since we want to plot against :ϵ instead.\nThe use_adiabatic kwarg sets how states are connected in the line plot across different fields. The default is use_adiabatic=true, which uses :adiabatic_index to connect the states. If use_adiabatic=false, then :index (counts energies at a given field from lowest to highest) is used instead.","category":"page"},{"location":"man/worked_example/#Plotting-transition-dipoles","page":"Example: dipole moments vs E","title":"Plotting transition dipoles","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Let's next plot the dipole matrix elements between different states. To do this, we'll call transitions:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"ts = transitions(spectra, parts, State(0, 0); restrict_N=false, cutoff=nothing);","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"The third argument, State(0, 0), sets the \"ground state\" for this calculation. The dipole moments between this state and each other state are computed and  stored in the columns :d_0, :d_plus, and :d_minus.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Note that we also override some of the default keyword args. The defaults have a nice behavior for some other calculations, but aren't the best here. See the docs for transitions for more info.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"We can plot these up. Here are the d^0 matrix elements:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"plot_transition_dipole(ts, State(0, 0), 0; groupby=:ϵ);\nCairoMakie.save(\"transition_dipoles_0.svg\", ans); nothing # hide","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"(Image: )","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"The third argument sets which spherical tensor component of the dipole operator is plotted. We can plot the d^+1 matrix elements instead:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"plot_transition_dipole(ts, State(0, 0), 1; groupby=:ϵ);\nCairoMakie.save(\"transition_dipoles_1.svg\", ans); nothing # hide","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"(Image: )","category":"page"},{"location":"man/worked_example/#Dumping-the-outputs-to-a-file","page":"Example: dipole moments vs E","title":"Dumping the outputs to a file","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"For later use, we often want to output the results to a file. In this example, we'll put induced dipole moments of 00rangle and 10rangle and the transition dipole moment between them into a CSV file.","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"We've already calculated all the necessary dipole moments, but the DataFrame  also has a bunch of extra information. We can remind ourselves by running the following command:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"names(ts)","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Let's select what we want into a new DataFrame:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"n_0_and_1 = filter_rotational(dips, [0, 1], 0);\nd_inds = DataFrames.select(n_0_and_1, [:ϵ, :N, :m_n, :d_ind])","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"The data is currently in \"long format\", with separate rows for 00rangle and 10rangle at each field. For this example, let's put it in \"wide format\" instead, so we have a single row at each field with the induced dipoles (:d00 and :d11) as the columns. For this, we can use the wide_format function:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"formatted = wide_format(d_inds, :d_ind, row -> \"d$(row.N)$(row.N)\"; groupby=:ϵ)","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"To get the transition dipole, we can filter our original DataFrame and join it with formatted:","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"d_transition = DataFrames.select(filter_rotational(ts, 1, 0), [:ϵ, :d_0]);\nDataFrames.transform!(d_transition, :d_0 => DataFrames.ByRow(abs) => :d01);\nDataFrames.select!(d_transition, [:ϵ, :d01]);\n\nformatted = DataFrames.DataAPI.rightjoin(formatted, d_transition; on=:ϵ)","category":"page"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Now that we have it in the right format, we can easily save it to a CSV.","category":"page"},{"location":"man/worked_example/#Custom-plotting-with-CairoMakie.jl","page":"Example: dipole moments vs E","title":"Custom plotting with CairoMakie.jl","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Plan: Put a custom plot here using the contents of formatted.","category":"page"},{"location":"man/worked_example/#Plotting-shortcuts","page":"Example: dipole moments vs E","title":"Plotting shortcuts","text":"","category":"section"},{"location":"man/worked_example/","page":"Example: dipole moments vs E","title":"Example: dipole moments vs E","text":"Plan: Show examples of the other signatures of the above plotting methods (the ones that take hamiltonian_parts).","category":"page"},{"location":"internals/fields/","page":"Fields","title":"Fields","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/fields/#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"internals/fields/","page":"Fields","title":"Fields","text":"Pages = [\"fields.md\"]","category":"page"},{"location":"internals/fields/#Types","page":"Fields","title":"Types","text":"","category":"section"},{"location":"internals/fields/","page":"Fields","title":"Fields","text":"Modules = [BialkaliSpectrum]\nPages = [\"fields.jl\"]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"internals/fields/#BialkaliSpectrum.SphericalUnitVector","page":"Fields","title":"BialkaliSpectrum.SphericalUnitVector","text":"SphericalUnitVector(magnitude, θ, φ)\nSphericalUnitVector(v::SphericalVector)\n\nConstruct a unit vector with polar angle θ, and azimuthal angle φ.\n\nRepresents the direction of an external field vector in spherical coordinates. Currently, SphericalUnitVectors may be negated but no other mathematical operations are implemented.\n\nVectors along x, y, or z can be quickly constructed using UnitVectorX, UnitVectorY, and UnitVectorZ, respectively.\n\nSee also SphericalVector, T⁽¹⁾, T⁽²⁾.\n\n\n\n\n\n","category":"type"},{"location":"internals/fields/#Methods","page":"Fields","title":"Methods","text":"","category":"section"},{"location":"internals/fields/","page":"Fields","title":"Fields","text":"Modules = [BialkaliSpectrum]\nPages = [\"fields.jl\"]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"internals/fields/#BialkaliSpectrum.T⁽²⁾-Tuple{BialkaliSpectrum.SphericalUnitVector}","page":"Fields","title":"BialkaliSpectrum.T⁽²⁾","text":"T⁽²⁾(v)\n\nConstruct the components of the rank 2 spherical tensor T²(v v).\n\n\n\n\n\n","category":"method"},{"location":"internals/fields/#BialkaliSpectrum.T⁽¹⁾-Tuple{BialkaliSpectrum.SphericalUnitVector}","page":"Fields","title":"BialkaliSpectrum.T⁽¹⁾","text":"T⁽¹⁾(v)\n\nConstruct the components of the rank 1 spherical tensor T¹(v).\u0013\n\n\n\n\n\n","category":"method"},{"location":"internals/fields/#BialkaliSpectrum.UnitVectorX-Tuple{}","page":"Fields","title":"BialkaliSpectrum.UnitVectorX","text":"UnitVectorX()\n\nConstruct a SphericalUnitVector along x.\n\n\n\n\n\n","category":"method"},{"location":"internals/fields/#BialkaliSpectrum.UnitVectorY-Tuple{}","page":"Fields","title":"BialkaliSpectrum.UnitVectorY","text":"UnitVectorY()\n\nConstruct a SphericalUnitVector along y.\n\n\n\n\n\n","category":"method"},{"location":"internals/fields/#BialkaliSpectrum.UnitVectorZ-Tuple{}","page":"Fields","title":"BialkaliSpectrum.UnitVectorZ","text":"UnitVectorZ()\n\nConstruct a SphericalUnitVector along z.\n\n\n\n\n\n","category":"method"},{"location":"internals/fields/#BialkaliSpectrum.tensor_dot-Tuple{Any, Any}","page":"Fields","title":"BialkaliSpectrum.tensor_dot","text":"tensor_dot(a, b)\n\nContract two spherical tensors a and b.\n\n\n\n\n\n","category":"method"},{"location":"internals/analysis/","page":"Analysis","title":"Analysis","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"internals/analysis/","page":"Analysis","title":"Analysis","text":"Pages = [\"analysis.md\"]","category":"page"},{"location":"internals/analysis/#Types","page":"Analysis","title":"Types","text":"","category":"section"},{"location":"internals/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [BialkaliSpectrum]\nPages = [\"analysis.jl\"]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"internals/analysis/#Methods","page":"Analysis","title":"Methods","text":"","category":"section"},{"location":"internals/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [BialkaliSpectrum]\nPages = [\"analysis.jl\"]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"internals/analysis/#BialkaliSpectrum.dressed_dipole_moment-Tuple{HamiltonianParts, Any, Any, Int64}","page":"Analysis","title":"BialkaliSpectrum.dressed_dipole_moment","text":"dressed_dipole_moment(\n    hamiltonian_parts::HamiltonianParts,\n    g,\n    e,\n    polarization::Int,\n)::ComplexF64\n\n\n\n\n\n","category":"method"},{"location":"internals/analysis/#BialkaliSpectrum.dressed_dipole_moment_vector-Tuple{HamiltonianParts, Any, Any}","page":"Analysis","title":"BialkaliSpectrum.dressed_dipole_moment_vector","text":"dressed_dipole_moment_vector(\n    hamiltonian_parts::HamiltonianParts,\n    g,\n    e,\n    polarization::Int,\n)::Vector{ComplexF64}\n\n\n\n\n\n","category":"method"},{"location":"internals/analysis/#BialkaliSpectrum.with_ground_state-Tuple{Any, State}","page":"Analysis","title":"BialkaliSpectrum.with_ground_state","text":"with_ground_state(\n    spectra,\n    ground_basis_state::State;\n    groupby=:fields\n)\n\nReturns a new DataFrame with the contents of spectra, plus an additional column :ground_state containing the :index of the state with the highest overlap with ground_basis_state, in the same group determined by groupby.\n\nUsed internally but not necessary probably??\n\n\n\n\n\n","category":"method"},{"location":"internals/state/","page":"State","title":"State","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/state/#State","page":"State","title":"State","text":"","category":"section"},{"location":"internals/state/","page":"State","title":"State","text":"Pages = [\"state.md\"]","category":"page"},{"location":"internals/state/#Types","page":"State","title":"Types","text":"","category":"section"},{"location":"internals/state/","page":"State","title":"State","text":"","category":"page"},{"location":"internals/state/#Methods","page":"State","title":"Methods","text":"","category":"section"},{"location":"internals/state/","page":"State","title":"State","text":"n_hyperfine","category":"page"},{"location":"internals/state/#BialkaliSpectrum.n_hyperfine","page":"State","title":"BialkaliSpectrum.n_hyperfine","text":"n_hyperfine(I)\nn_hyperfine(s::State)\n\nReturns the number of hyperfine components for nuclear spin I, or the number of hyperfine components in the basis to which s belongs.\n\n\n\n\n\n","category":"function"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"api/setting_up/#Setting-up-a-calculation","page":"Setting up a calculation","title":"Setting up a calculation","text":"","category":"section"},{"location":"api/setting_up/#Contents","page":"Setting up a calculation","title":"Contents","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Pages = [\"setting_up.md\"]","category":"page"},{"location":"api/setting_up/#Index","page":"Setting up a calculation","title":"Index","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Pages = [\"setting_up.md\"]","category":"page"},{"location":"api/setting_up/#Molecular-parameters","page":"Setting up a calculation","title":"Molecular parameters","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Structs for organizing the coupling constants, dipole moment, and nuclear spins of the molecule.","category":"page"},{"location":"api/setting_up/#Types","page":"Setting up a calculation","title":"Types","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"molecular_parameters.jl\"]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.MolecularParameters","page":"Setting up a calculation","title":"BialkaliSpectrum.MolecularParameters","text":"MolecularParameters\n\nContains the coupling constants for the molecular Hamiltonian and the nuclear angular momenta (needed to  construct the basis states).\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#BialkaliSpectrum.NuclearParameters","page":"Setting up a calculation","title":"BialkaliSpectrum.NuclearParameters","text":"NuclearParameters\n\nContains the nuclear electric quadrupole moments, nuclear spin-rotation couplings, and nuclear spin-spin coupling for calculating the hyperfine Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#BialkaliSpectrum.Polarizability","page":"Setting up a calculation","title":"BialkaliSpectrum.Polarizability","text":"Polarizability\n\nContains the parallel and perpendicular ac polarizabilities at a particular optical wavelength λ.\n\nSo far, it is assumed that λ is far-detuned from any electronic transitions, such that the polarizability does not depend on rotational state N.\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#BialkaliSpectrum.ZeemanParameters","page":"Setting up a calculation","title":"BialkaliSpectrum.ZeemanParameters","text":"ZeemanParameters\n\nContains the g-factors and nuclear shielding factors for computing Zeeman shifts.\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#Constants","page":"Setting up a calculation","title":"Constants","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"molecular_parameters.jl\"]\nPrivate = false\nOrder = [:constant]","category":"page"},{"location":"api/setting_up/#Hamiltonian","page":"Setting up a calculation","title":"Hamiltonian","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Functions for building the molecular Hamiltonian.","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"The HamiltonianParts struct is used as an input to several analysis methods, e.g. computing dipole matrix elements, since it holds the individual terms in the Hamiltonian separately.","category":"page"},{"location":"api/setting_up/#Types-2","page":"Setting up a calculation","title":"Types","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"hamiltonian.jl\"]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.HamiltonianParts","page":"Setting up a calculation","title":"BialkaliSpectrum.HamiltonianParts","text":"HamiltonianParts\n\nContains all parts of the Hamiltonian except external fields.\n\nZeeman, dc Stark, and ac Stark terms are stored as vectors of matrices that can be contracted with the appropriate external field tensors. This allows the full Hamiltonian to be re-constructed at various field values and orientations without recalculating all of the matrix elements.\n\nShould be created by make_hamiltonian_parts or make_krb_hamiltonian_parts. Used as an input to get_spectrum and hamiltonian.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts.\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#Methods","page":"Setting up a calculation","title":"Methods","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"hamiltonian.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.hamiltonian-Tuple{HamiltonianParts, ExternalFields}","page":"Setting up a calculation","title":"BialkaliSpectrum.hamiltonian","text":"hamiltonian(parts, external_fields)\n\nConstruct the full Hamiltonian including magnetic, electric, and optical fields.\n\nThe field-independent building blocks in parts can be reused over calls to hamiltonian to avoid recalculating the matrix elements each time.\n\nSee also make_hamiltonian_parts, make_krb_hamiltonian_parts, ExternalFields.\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.make_hamiltonian_parts-Tuple{MolecularParameters, Int64}","page":"Setting up a calculation","title":"BialkaliSpectrum.make_hamiltonian_parts","text":"make_hamiltonian_parts(molecular_parameters, N_max)\n\nConstruct all parts of the Hamiltonian that do not depend on external fields.\n\nThe size of the basis is determined by molecular_parameters, which contains the nuclear spin quantum numbers molecular_parameters.I, and the rotational states 0:N_max to include.\n\nSee also make_krb_hamiltonian_parts.\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#Fields","page":"Setting up a calculation","title":"Fields","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Utilities for defining the external magnetic, electric, and optical fields experienced by the molecules.","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"The ExternalFields holds the external fields, which are each defined by a SphericalVector with a magnitude, polar angle theta, and azimuthal angle phi. Note that the molecular basis is defined with respect to the z-axis (theta = 0).","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"A Vector{ExternalFields} is expected by get_spectra, and can be generated manually or with generate_fields_scan.","category":"page"},{"location":"api/setting_up/#Types-3","page":"Setting up a calculation","title":"Types","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"fields.jl\"]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.ExternalFields","page":"Setting up a calculation","title":"BialkaliSpectrum.ExternalFields","text":"ExternalFields(B::SphericalVector, E::SphericalVector, Optical::Vector{SphericalVector})\nExternalFields(B::Float64, E::Float64)\n\nExternal magnetic, electric, optical fields to use in constructing the Hamiltonian.\n\nIf B and E are provided as Float64s, then the fields are assumed to be along z. The Optical argument can also be left as an empty vector [].\n\nSee also get_spectrum, hamiltonian, SphericalVector.\n\nTODO: add the other signatures\n\nExamples\n\njulia> ExternalFields(VectorZ(545.9), VectorX(1020.0), [])\nExternalFields(SphericalVector(545.9, 0.0, 0.0), SphericalVector(1020.0, 1.5707963267948966, 0.0), SphericalVector[])\n\njulia> ExternalFields(545.9, 1020.0)\nExternalFields(SphericalVector(545.9, 0.0, 0.0), SphericalVector(1020.0, 0.0, 0.0), SphericalVector[])\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#BialkaliSpectrum.SphericalVector","page":"Setting up a calculation","title":"BialkaliSpectrum.SphericalVector","text":"SphericalVector(magnitude, θ, φ)\n\nConstruct a vector with magnitude, polar angle θ, and azimuthal angle φ.\n\nRepresents an external field vector in spherical coordinates used to construct ExternalFields. Currently, SphericalVectors may be negated but no other mathematical operations are implemented.\n\nVectors along x, y, or z can be quickly constructed using VectorX, VectorY, and VectorZ, respectively.\n\nSee also SphericalUnitVector, ExternalFields.\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#Methods-2","page":"Setting up a calculation","title":"Methods","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"fields.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.VectorX-Tuple{Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.VectorX","text":"VectorX(magnitude)\n\nConstruct a SphericalVector with magnitude along x.\n\nExamples\n\njulia> VectorX(5.0)\nSphericalVector(5.0, 1.5707963267948966, 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.VectorY-Tuple{Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.VectorY","text":"VectorY(magnitude)\n\nConstruct a SphericalVector with magnitude along y.\n\nExamples\n\njulia> VectorY(2.0)\nSphericalVector(2.0, 1.5707963267948966, 1.5707963267948966)\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.VectorZ-Tuple{Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.VectorZ","text":"VectorZ(magnitude)\n\nConstruct a SphericalVector with magnitude along z.\n\nExamples\n\njulia> VectorZ(10.0)\nSphericalVector(10.0, 0.0, 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.generate_fields_scan-Tuple{Any, Any, Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.generate_fields_scan","text":"generate_fields_scan(Bs, Es, Opticals)\n\nProduce a vector of ExternalFields for creating a scan of spectra as a function of fields.\n\nTODO: explain the behavior as a product of the lists (not zipped)\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#Basis-states","page":"Setting up a calculation","title":"Basis states","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Utilities for working with molecular states in the uncoupled basis N m_N m_i1 m_i2 rangle.","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"The basis states are indexed with the quantum numbers changing fastest on the right. For example, with I_1 = 12 and I_2 = 12, the first few states are:","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"0 0 -12 -12\n0 0 -12 +12\n0 0 +12 -12\n0 0 +12 +12\n1 -1 -12 -12","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"etc.","category":"page"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"The methods basis_state and basis_index are used to switch between an index and the corresponding basis State.","category":"page"},{"location":"api/setting_up/#Types-4","page":"Setting up a calculation","title":"Types","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"state.jl\"]\nPrivate = false\nOrder = [:type]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.State","page":"Setting up a calculation","title":"BialkaliSpectrum.State","text":"State(N, mₙ, I, mᵢ)    \nState(N, mₙ, I₁, mᵢ₁, I₂, mᵢ₂)\n\nRepresents a molecular state in the uncoupled basis N mₙ I₁ mᵢ₁ I₂ mᵢ₂.\n\nWrite something more descriptive here\n\n\n\n\n\n","category":"type"},{"location":"api/setting_up/#Standard-library-interfaces","page":"Setting up a calculation","title":"Standard library interfaces","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"convert\nshow","category":"page"},{"location":"api/setting_up/#Base.convert","page":"Setting up a calculation","title":"Base.convert","text":"Base.convert(t::Type{NamedTuple}, s::State)\n\nReturns a named tuple with fields N, m_n, I_1, m_i1, I_2, m_i2 from s.\n\nThis is a utility function to simplify outputting to a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/setting_up/#Base.show","page":"Setting up a calculation","title":"Base.show","text":"Base.show(io::IO, s::State)\n\nPretty prints a State in ket notation, N m_N m_i1 m_i2.\n\n\n\n\n\n","category":"function"},{"location":"api/setting_up/#Methods-3","page":"Setting up a calculation","title":"Methods","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum]\nPages = [\"state.jl\"]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.basis_index-Tuple{State}","page":"Setting up a calculation","title":"BialkaliSpectrum.basis_index","text":"basis_index(s::State)\n\nReturns index of state s in the basis.\n\nThe uncoupled basis N mₙ I₁ mᵢ₁ I₂ mᵢ₂ is ordered with the quantum numbers on the left changing the slowest.\n\nSee also State, basis_index.\n\nExamples\n\njulia> import BialkaliSpectrum.K40Rb87: KRbState\n\njulia> basis_index(KRbState(1, 1, -4, 1/2))\n111\n\njulia> basis_index(basis_state(42, 4, 3/2))\n42\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.basis_state-Tuple{Int64, Any, Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.basis_state","text":"basis_state(i, I₁, I₂)\n\nReturns the State corresponding to the ith member of the basis.\n\nThe uncoupled basis N mₙ I₁ mᵢ₁ I₂ mᵢ₂ is ordered with the quantum numbers on the left changing the slowest.\n\nSee also State, basis_index.\n\nExamples\n\njulia> s = basis_state(1, 4, 3/2)\nBialkaliSpectrum.State basis state:\n    |0, 0, -4, -3/2⟩\n\njulia> s = basis_state(37, 4, 3/2)\nBialkaliSpectrum.State basis state:\n    |1, -1, -4, -3/2⟩\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#Molecule-specific-definitions","page":"Setting up a calculation","title":"Molecule-specific definitions","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Constants and method defs for working with specific molecule species.","category":"page"},{"location":"api/setting_up/#{}{40}\\text{K}{87}\\text{Rb}-(K40Rb87)","page":"Setting up a calculation","title":"^40textK^87textRb (K40Rb87)","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum.K40Rb87]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Nuclear_Neyenhuis","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Nuclear_Neyenhuis","text":"KRb_Nuclear_Neyenhuis\n\nExperimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Nuclear_Ospelkaus","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Nuclear_Ospelkaus","text":"KRb_Nuclear_Ospelkaus\n\nExperimental values from Ospelkaus et al., PRL 104, 030402 (2010)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Parameters_Neyenhuis","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Parameters_Neyenhuis","text":"KRb_Parameters_Neyenhuis\n\nExperimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Parameters_Ospelkaus","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Parameters_Ospelkaus","text":"KRb_Parameters_Ospelkaus\n\nExperimental values from Ospelkaus et al., PRL 104, 030402 (2010)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Polarizability","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Polarizability","text":"KRb_Polarizability\n\nExperimental values from Neyenhuis et al., PRL 109, 230403 (2012)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRb_Zeeman","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRb_Zeeman","text":"KRb_Zeeman\n\nTheoretical values from Aldegunde et al. PRA (2008)\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.KRbState-NTuple{4, Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.KRbState","text":"KRbState(N, mₙ, mK, mRb)\n\nCreates a basis state N m_n m_textK m_textRb for ^40textK^87textRb.\n\nThis is a wrapper around State to avoid having to specify the nuclear spins I_k each time.\n\nSee also State.\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.K40Rb87.make_krb_hamiltonian_parts-Tuple{Int64}","page":"Setting up a calculation","title":"BialkaliSpectrum.K40Rb87.make_krb_hamiltonian_parts","text":"make_krb_hamiltonian_parts(N_max::Int)\n\nConstruct all parts of the ^40textK^87textRb Hamiltonian that do not depend on external fields.\n\nThe rotational states 0:N_max are included. This is a shortcut method that replaces make_hamiltonian_parts for KRb.\n\nSee also make_hamiltonian_parts.\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#Toy-molecule-without-hyperfine-structure-(Toy)","page":"Setting up a calculation","title":"Toy molecule without hyperfine structure (Toy)","text":"","category":"section"},{"location":"api/setting_up/","page":"Setting up a calculation","title":"Setting up a calculation","text":"Modules = [BialkaliSpectrum.Toy]","category":"page"},{"location":"api/setting_up/#BialkaliSpectrum.Toy.TOY_PARAMETERS","page":"Setting up a calculation","title":"BialkaliSpectrum.Toy.TOY_PARAMETERS","text":"TOY_PARAMETERS\n\nToy model values with dipole = 1 D and no hyperfine structure. Intended for testing.\n\n\n\n\n\n","category":"constant"},{"location":"api/setting_up/#BialkaliSpectrum.State-Tuple{Any, Any}","page":"Setting up a calculation","title":"BialkaliSpectrum.State","text":"State(N, mₙ)\n\nCreates a basis state N m_n for the toy molecule.\n\nThis is a wrapper around State to avoid having to specify the nuclear spins I_k each time.\n\nSee also State.\n\n\n\n\n\n","category":"method"},{"location":"api/setting_up/#BialkaliSpectrum.Toy.make_toy_hamiltonian_parts-Tuple{Int64}","page":"Setting up a calculation","title":"BialkaliSpectrum.Toy.make_toy_hamiltonian_parts","text":"make_toy_hamiltonian_parts(N_max::Int)\n\nConstruct all parts of the toy molecule Hamiltonian that do not depend on external fields.\n\nThe rotational states 0:N_max are included. This is a shortcut method that replaces make_hamiltonian_parts for the toy molecule.\n\nSee also make_hamiltonian_parts.\n\n\n\n\n\n","category":"method"},{"location":"internals/constants/","page":"Constants","title":"Constants","text":"CurrentModule = BialkaliSpectrum","category":"page"},{"location":"internals/constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"internals/constants/","page":"Constants","title":"Constants","text":"Pages = [\"constants.md\"]","category":"page"},{"location":"internals/constants/#Constants-2","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"internals/constants/","page":"Constants","title":"Constants","text":"Modules = [BialkaliSpectrum.Constants]\nPublic = false","category":"page"},{"location":"internals/constants/#BialkaliSpectrum.Constants.DToSI","page":"Constants","title":"BialkaliSpectrum.Constants.DToSI","text":"Factor to convert from Debye to C m\n\n\n\n\n\n","category":"constant"},{"location":"internals/constants/#BialkaliSpectrum.Constants.DVcm⁻¹ToMHz","page":"Constants","title":"BialkaliSpectrum.Constants.DVcm⁻¹ToMHz","text":"Convert from D*(V/cm) to MHz\n\n\n\n\n\n","category":"constant"},{"location":"internals/constants/#BialkaliSpectrum.Constants.h","page":"Constants","title":"BialkaliSpectrum.Constants.h","text":"Planck's constant (SI)\n\n\n\n\n\n","category":"constant"},{"location":"internals/constants/#BialkaliSpectrum.Constants.μN","page":"Constants","title":"BialkaliSpectrum.Constants.μN","text":"Nuclear magneton in MHz/G\n\n\n\n\n\n","category":"constant"},{"location":"#BialkaliSpectrum.jl","page":"Home","title":"BialkaliSpectrum.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculate the energy levels of diatomic ^1 Sigma^+ molecules in magnetic, electric, and optical fields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example calculation: ^40textK^87textRb transitions from a particular hyperfine state as a function of electric field.  (Image: )","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/basics.md\",\n    \"man/worked_example.md\",\n]\nDepth = 2","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/setting_up.md\",\n    \"api/analyzing_spectrum.md\",\n]\nDepth = 3","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"internals/constants.md\",\n    \"internals/state.md\",\n    \"internals/matrix_elements.md\",\n    \"internals/hamiltonian.md\",\n    \"internals/fields.md\",\n    \"internals/analysis.md\",\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"}]
}
